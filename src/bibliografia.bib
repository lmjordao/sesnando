% ------------------------- First Software Engineer -------------------------
@misc{first_sw_engineer,
	title = {First {Software} {Engineer} {\textbar} {IEEE} {Computer} {Society}},
	url = {https://www.computer.org/publications/tech-news/events/what-to-know-about-the-scientist-who-invented-the-term-software-engineering/},
	abstract = {Empowering the People who Drive Technology},
	language = {en-US},
	urldate = {2021-11-14},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\R7SJ5FMB\\what-to-know-about-the-scientist-who-invented-the-term-software-engineering.html:text/html},
}

% ------------------------- Her code -------------------------
@article{mcmillan_her_nodate,
	title = {Her {Code} {Got} {Humans} on the {Moon}—{And} {Invented} {Software} {Itself}},
	issn = {1059-1028},
	url = {https://www.wired.com/2015/10/margaret-hamilton-nasa-apollo/},
	abstract = {Instead of just supporting her husband’s career, Margaret Hamilton invented the modern concept of software.},
	language = {en-US},
	urldate = {2021-11-14},
	journal = {Wired},
	author = {McMillan, Robert},
	note = {Section: tags},
	keywords = {code, enterprise, space, wired instagram, women in tech},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\5EQFMZQG\\margaret-hamilton-nasa-apollo.html:text/html},
}

% ------------------------- History of software testing -------------------------
@misc{hernandez_history_2020,
	title = {History of software testing},
	url = {https://davidmoremad.medium.com/history-of-software-testing-cfa461c4ae0a},
	abstract = {The testing phase is one of the most important tasks of any tech-business, but has been present since the beginning of computing},
	language = {en},
	urldate = {2021-11-14},
	journal = {Medium},
	author = {Hernandez, David Amrani},
	month = nov,
	year = {2020},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\4QF32ET6\\history-of-software-testing-cfa461c4ae0a.html:text/html},
}

% ------------------------- SOFTWARE REQUIREMENTS -------------------------
@book{aurum_engineering_2005,
	title = {Engineering and {Managing} {Software} {Requirements}},
	isbn = {978-3-540-25043-2},
	abstract = {Requirements engineering is the process by which the requirements for software systems are gathered, analyzed, documented, and managed throughout their complete lifecycle. Traditionally it has been concerned with technical goals for, functions of, and constraints on software systems. Aurum and Wohlin, however, argue that it is no longer appropriate for software systems professionals to focus only on functional and non-functional aspects of the intended system and to somehow assume that organizational context and needs are outside their remit. Instead, they call for a broader perspective in order to gain a better understanding of the interdependencies between enterprise stakeholders, processes, and software systems, which would in turn give rise to more appropriate techniques and higher-quality systems. Following an introductory chapter that provides an exploration of key issues in requirements engineering, the book is organized in three parts. Part 1 presents surveys of state-of-the art requirements engineering process research along with critical assessments of existing models, frameworks and techniques. Part 2 addresses key areas in requirements engineering, such as market-driven requirements engineering, goal modeling, requirements ambiguity, and others. Part 3 concludes the book with articles that present empirical evidence and experiences from practices in industrial projects. Its broader perspective gives this book its distinct appeal and makes it of interest to both researchers and practitioners, not only in software engineering but also in other disciplines such as business process engineering and management science.},
	language = {en},
	publisher = {Springer Science \& Business Media},
	author = {Aurum, Ayba1/4ke and Wohlin, Claes},
	month = jul,
	year = {2005},
	note = {Google-Books-ID: pUG1IaikDhMC},
	keywords = {Business \& Economics / Business Mathematics, Business \& Economics / Information Management, Computers / Computer Architecture, Computers / Computer Engineering, Computers / Information Technology, Computers / Software Development \& Engineering / General},
}

% ------------------------- INCOSE -------------------------
@article{incose,
	title = {{INCOSE} {Guide} for {Writing} {Requirements}. {Translation} experience, adaptation perspectives},
	abstract = {This article describes the document “INCOSE Guide for writing requirements” as a product, and the project for its translation as a focused organized activity. The article should make for the reader clear what exactly he or she can expect from the document and its translation, how to use the document in practice and how to organise projects for the translation of such documents.},
	language = {en},
	author = {Alexandrovich, Alexander and Igorevich, Kirill},
	pages = {15},
	file = {Alexandrovich and Igorevich - INCOSE Guide for Writing Requirements. Translation.pdf:C\:\\Users\\lmjordao\\Zotero\\storage\\2QIFZRI3\\Alexandrovich and Igorevich - INCOSE Guide for Writing Requirements. Translation.pdf:application/pdf},
}

% ------------------------- SMART requirements -------------------------
@article{mannion_smart_2004,
	title = {{SMART} requirements},
	volume = {20},
	doi = {10.1145/224155.224157},
	abstract = {Requirements Engineering, is a time consuming, expensive but critical phase in software (and system) development. The "perfect" Requirements Specification should exhibit a number of qualities including correctness, completeness and consistency. Within a Requirements Specification individual requirements at the microscopic level should be justified, clear, unambiguous and verifiable. However, in many cases Systems Analysts or Requirements Engineers describe requirements which fall short of these demands. In addition, outside reviewers faced with presenting an independent qualitative assessment of a Requirements Specification have few guidelines to assist them. In this paper we present a simple technique, borrowed from objective setting in Management Psychology, to assist the construction and evaluation of individual requirements.},
	journal = {ACM SIGSOFT Software Engineering Notes},
	author = {Mannion, Mike and Keepence, Barry},
	month = mar,
	year = {2004},
	file = {Full Text PDF:C\:\\Users\\lmjordao\\Zotero\\storage\\ZHXEZQVB\\Mannion and Keepence - 2004 - SMART requirements.pdf:application/pdf},
}


% ------------------------- VNV -------------------------
@misc{noauthor_independent_2013,
	title = {Independent {Verification} and {Validation} ({IV}\&{V}) {Through} the {Eyes} of {DoD}},
	url = {https://logapps.com/2013/07/independent-verification-and-validation/},
	abstract = {IT departments at different agencies and organizations each have ways of conducting their testing and evaluation activities. In the eyes of the U.S. Department of Defense, Independent Verification and Validation (IV\&V) is an independent system assessment that analyzes and test target systems.},
	language = {en-US},
	urldate = {2021-11-15},
	journal = {Logapps, LLC},
	month = jul,
	year = {2013},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\U8RX5SVQ\\independent-verification-and-validation.html:text/html},
}

% ------------------------- CUCUMBER -------------------------
@misc{cucumber,
	title = {Step {Definitions} - {Cucumber} {Documentation}},
	url = {https://cucumber.io/docs/cucumber/step-definitions/},
	urldate = {2021-08-07},
	file = {Step Definitions - Cucumber Documentation:C\:\\Users\\lmjordao\\Zotero\\storage\\CZTGTS65\\step-definitions.html:text/html},
}

% ------------------------- n_gram -------------------------
@article{broder_syntactic_1997,
	title = {Syntactic clustering of the Web},
	volume = {29},
	issn = {0169-7552},
	url = {https://www.sciencedirect.com/science/article/pii/S0169755297000317},
	doi = {10.1016/S0169-7552(97)00031-7},
	series = {Papers from the Sixth International World Wide Web Conference},
	abstract = {We have developed an efficient way to determine the syntactic similarity of files and have applied it to every document on the World Wide Web. Using this mechanism, we built a clustering of all the documents that are syntactically similar. Possible applications include a “Lost and Found” service, filtering the results of Web searches, updating widely distributed web-pages, and identifying violations of intellectual property rights.},
	pages = {1157--1166},
	number = {8},
	journaltitle = {Computer Networks and {ISDN} Systems},
	shortjournal = {Computer Networks and {ISDN} Systems},
	author = {Broder, Andrei Z. and Glassman, Steven C. and Manasse, Mark S. and Zweig, Geoffrey},
	urldate = {2021-11-05},
	date = {1997-09-01},
	langid = {english},
	keywords = {Duplication, Fingerprints, Resemblance, Signatures, Similarity, Web search},
	file = {ScienceDirect Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\W2A7ZHY8\\S0169755297000317.html:text/html},
}

% ------------------------- flex_bison -------------------------
@book{levine_flex_2009,
	title = {Flex \& {Bison}: {Text} {Processing} {Tools}},
	isbn = {978-1-4493-9197-3},
	shorttitle = {Flex \& {Bison}},
	abstract = {If you need to parse or process text data in Linux or Unix, this useful book explains how to use flex and bison to solve your problems quickly. flex \& bison is the long-awaited sequel to the classic O'Reilly book, lex \& yacc. In the nearly two decades since the original book was published, the flex and bison utilities have proven to be more reliable and more powerful than the original Unix tools. flex \& bison covers the same core functionality vital to Linux and Unix program development, along with several important new topics. You'll find revised tutorials for novices and references for advanced users, as well as an explanation of each utility's basic usage and simple, standalone applications you can create with them. With flex \& bison, you'll discover the wide range of uses these flexible tools offer.Address syntax crunching that regular expressions tools can't handleBuild compilers and interpreters, and handle a wide range of text processing functionsInterpret code, configuration files, or any other structured formatLearn key programming techniques, including abstract syntax trees and symbol tablesImplement a full SQL grammar-with complete sample codeUse new features such as pure (reentrant) lexers and parsers, powerful GLR parsers, and interfaces to C++},
	language = {en},
	publisher = {"O'Reilly Media, Inc."},
	author = {Levine, John},
	month = aug,
	year = {2009},
	note = {Google-Books-ID: nYUkAAAAQBAJ},
	keywords = {Computers / General, Computers / Languages / JavaScript, Computers / Operating Systems / General, Computers / Operating Systems / Linux, Computers / Operating Systems / UNIX, Computers / Programming / Compilers, Computers / Programming / General},
}

% ------------------------- antlr site -------------------------
@misc{antlr_site,
	title = {The {Definitive} {ANTLR} 4 {Reference}},
	url = {https://pragprog.com/titles/tpantlr2/the-definitive-antlr-4-reference},
	abstract = {We improve the lives of professional developers. We create timely, practical books on classic and cutting-edge topics to help you learn and practice your craft, and accelerate your career. Come learn with us.},
	language = {en},
	urldate = {2021-11-05},
	note = {ISBN: 9781934356999},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\PU7GVWMS\\the-definitive-antlr-4-reference.html:text/html},
}
% ------------------------- software testing -------------------------
@book{jorgensen_software_2011,
	address = {New York},
	edition = {3},
	title = {Software {Testing}: {A} {Craftsman}'s {Approach}, {Third} {Edition}},
	isbn = {978-0-429-18457-4},
	shorttitle = {Software {Testing}},
	abstract = {Since the last publication of this international bestseller, software testing has seen a renaissance of renewed interest and technology. The biggest change comes in the growing prominence and acceptance of Agile Programming. Software Testing: A Craftsman's Approach, Third Edition extends the combination of theory and practicality of the first},
	publisher = {Auerbach Publications},
	author = {Jorgensen, Paul C.},
	month = oct,
	year = {2011},
	doi = {10.1201/9781439889503},
}
% ------------------------- CEG -------------------------
@inproceedings{nursimulu_cause-effect_1995,
	title = {Cause-{Effect} {Graphing} {Analysis} and {Validation} of {Requirements}},
	abstract = {Cause-Effect Graphing (CEG) is used to derive test cases from a given natural language specification to validate its corresponding implementation. This paper surveys some known drawbacks to CEG analysis and shows how these can be overcome. It also shows how the CEG technique can be used to derive discriminating customer-directed scenarios (use-cases) for validating requirements.},
	booktitle = {In {Proceedings} of {CASCON}'95 , {IBM} {Canada} {Ltd}. and {National} {Research} {Council}},
	author = {Nursimulu, Khenaidoo and Probert, Robert L.},
	year = {1995},
	pages = {293--293},
	file = {Citeseer - Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\G5QIYY2R\\summary.html:text/html;Citeseer - Full Text PDF:C\:\\Users\\lmjordao\\Zotero\\storage\\YKZIH9BS\\Nursimulu and Probert - 1995 - Cause-Effect Graphing Analysis and Validation of R.pdf:application/pdf},
}

% ------------------------- robustness testing -------------------------
@incollection{khendek_model-based_2005,
	address = {Berlin, Heidelberg},
	title = {A {Model}-{Based} {Approach} for {Robustness} {Testing}},
	volume = {3502},
	isbn = {978-3-540-26054-7 978-3-540-32076-0},
	url = {http://link.springer.com/10.1007/11430230_23},
	abstract = {Robustness testing is a part of the validation process which consists in testing the behavior of a system implementation under exceptional execution conditions in order to check if it still fulﬁlls some robustness requirements. We propose a theoretical framework for modelbased robustness testing together with an implementation within the If validation environment. Robustness test cases are generated from both a (partial) operational speciﬁcation and an abstract fault model. This generation technique is inspired from the ones used in (classical) conformance testing - already implemented in several tools. This framework is illustrated on a small example.},
	language = {en},
	urldate = {2021-11-07},
	booktitle = {Testing of {Communicating} {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Fernandez, Jean-Claude and Mounier, Laurent and Pachon, Cyril},
	editor = {Khendek, Ferhat and Dssouli, Rachida},
	year = {2005},
	doi = {10.1007/11430230_23},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {333--348},
	file = {Fernandez et al. - 2005 - A Model-Based Approach for Robustness Testing.pdf:C\:\\Users\\lmjordao\\Zotero\\storage\\UYZCUG3I\\Fernandez et al. - 2005 - A Model-Based Approach for Robustness Testing.pdf:application/pdf},
}

% ------------------------- Sesnando input requirement guidelines -------------------------
@misc{sesnando-req-guidelines,
	title = {{CSW}-{SESNANDO}-{Requirement}-{Guidelines}},
	shorttitle = {Sesnando input {Requirement} guidelines},
	abstract = {Grammar definition of the requirements that can be interpreted by sesnando.},
	language = {English},
	author = {Jordão, Luís},
	month = feb,
	year = {2021},
}

% ------------------------- en50126 -------------------------
@misc{en50126,
	title = {{CENELEC} - {EN} 50126-1 - {Railway} {Applications} - {The} {Specification} and {Demonstration} of {Reliability}, {Availability}, {Maintainability} and {Safety} ({RAMS}) - {Part} 1: {Generic} {RAMS} {Process} {\textbar} {Engineering360}},
	url = {https://standards.globalspec.com/std/10262901/EN%2050126-1},
	urldate = {2022-04-08},
	file = {CENELEC - EN 50126-1 - Railway Applications - The Specification and Demonstration of Reliability, Availability, Maintainability and Safety (RAMS) - Part 1\: Generic RAMS Process | Engineering360:C\:\\Users\\lmjordao\\Zotero\\storage\\ZN79H5N8\\EN 50126-1.html:text/html},
}

% ------------------------- cenelec50128 -------------------------
@online{cenelec50128,
	title = {{CENELEC} 50128 and {IEC} 62279 Standards {\textbar} Wiley},
	url = {https://www.wiley.com/en-us/CENELEC+50128+and+IEC+62279+Standards-p-9781848216341},
	abstract = {{CENELEC} {EN} 50128 and {IEC} 62279 standards are applicable to the performance of software in the railway sector. The 2011 version of the 50128 standard firms up the techniques and methods to be implemented. This is a guide to its implementation, in order to understand the foundations of the standard and how it impacts on the activities to be undertaken, helping towards better a preparation for the independent evaluation phase, which is mandatory.},
	titleaddon = {Wiley.com},
	urldate = {2022-04-25},
	langid = {english},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\CHTEBEFA\\CENELEC+50128+and+IEC+62279+Standards-p-9781848216341.html:text/html},
}

% ------------------------- cenelec50128 2-------------------------
@online{en50128_2,
	title = {{CENELEC} - {EN} 50128 - Railway applications - Communication, signalling and processing systems - Software for railway control and protection systems {\textbar} Engineering360},
	url = {https://standards.globalspec.com/std/14317747/EN%2050128},
	urldate = {2022-04-30},
	file = {CENELEC - EN 50128 - Railway applications - Communication, signalling and processing systems - Software for railway control and protection systems | Engineering360:C\:\\Users\\lmjordao\\Zotero\\storage\\RDQC5KRW\\EN 50128.html:text/html},
}

% ------------------------- en61131 -------------------------
@misc{en61131,
	title = {{EN} 61131-6},
	url = {https://www.en-standard.eu/csn-en-61131-6-programmable-controllers-part-6-functional-safety/},
	abstract = {CSN EN 61131-6 - Programmable controllers - Part 6: Functional safety, Category: 1870 Self-operated controllers},
	language = {en},
	urldate = {2022-04-08},
	journal = {https://www.en-standard.eu},
	author = {Standards, European},
	file = {Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\3KRWP66Z\\csn-en-61131-6-programmable-controllers-part-6-functional-safety.html:text/html},
}

% ------------------------- bnf_vs_ebnf -------------------------
@misc{bnf_vs_ebnf,
	title = {{BNF} and {EBNF}},
	url = {https://condor.depaul.edu/ichu/csc447/notes/wk3/BNF.pdf},
	urldate = {2022-04-15},
}

% ------------------------- ada book -------------------------
@book{ada_book,
	title = {Software Engineering with Ada},
	isbn = {978-0-8053-0608-8},
	abstract = {Introduction. The Software Crisis. The Ada Culture. 2. Software Engineering. Goals of Software Engineering. Principles of Software Engineering. Approaches to Software Development. Languages and Software Development. 3. Object-Oriented Design. Limitations of Functional Methods. An Object-Oriented Design Method. Ada as a Design Language. 4. An Overview Of The Language. Requirements for the Language. Ada from the Top Down. Ada from the Bottom Up. Summary of Language Characteristics. Data Structures. 5. The First Design Problem: Document Concordance. Define the Problem. Identify the Objects. Identify the Operations. Establish the Visibility. Establish the Interface. Implement Each Object. 6. Data Abstraction And Ada's Types. Data Abstraction. Types. Object Declarations. 7. The Second Design Problem: Data Base System. Define the Problem. Identify the Objects. Identify the Operations. Establish the Visibility. Establish the Interface. Algorithms And Control. 8. Subprograms. The Form of Ada Subprograms. Subprogram Calls. Applications for Ada Subprograms. 9. Expressions And Statements. Names. Values. Expressions. Statements. 10. The Second Design Problem: Continued. The Problem Revisited. Evaluate the Objects. Implement Each Object. Packaging Concepts. 11. Packages. The Form of Ada Packages. Packages and Private Types. Applications for Ada Packages. 12. Generic Program Units. The Form of Ada Generic Program Units. Generic Parameters. Applications for Ada Generic Program Units. 13. The Third Design Problem: Generic Tree Package. Define the Problem. Identify the Objects. Identify the Operations. Establish the Visibility. Establish the Interface. Evaluate the Objects. Implement Each Object. Concurrent Real-Time Processing. 14. Tasks. The Form of Ada Tasks. Task Statements. Applications for Ada Tasks. 15. Excep},
	pagetotal = {580},
	publisher = {Addison-Wesley Professional},
	author = {Booch, Grady and Bryan, Douglas L. and Petersen, Charles G.},
	date = {1994},
	langid = {english},
	note = {Google-Books-{ID}: {iPZGJRW}9bKgC},
	keywords = {Computers / Programming Languages / Ada},
}

% ------------------------- misra_c -------------------------
@article{misra_c,
	title = {Safer language subsets: an overview and a case history, {MISRA} C},
	volume = {46},
	issn = {0950-5849},
	url = {https://www.sciencedirect.com/science/article/pii/S0950584903002076},
	doi = {10.1016/j.infsof.2003.09.016},
	shorttitle = {Safer language subsets},
	abstract = {This paper gives an overview of safer language subsets in general and considers one widely-used one, {MISRA} C, in particular. The rationale, specification, implementation and enforcement of a safer language subset each introduce particular problems which has led to their inconsistent take-up over the years even in applications which may be safety-related and definitely need subset restrictions. Each of these areas will be discussed illustrating practical problems which may be encountered with standards in general before focussing on the widely used {MISRA} C standard [{MISRA} C guidelines (1998)]. The approach taken is necessarily empirical and where it is able quotes measurements. The real objective of this paper is to produce an empirically based taxonomy of programming language subset rules to bring all these issues together and promote the concept that a safer subset must be based on measurement principles however crudely they are practised currently in software development. The concept of signal to noise ratio of a programming standard is also introduced.},
	pages = {465--472},
	number = {7},
	journaltitle = {Information and Software Technology},
	shortjournal = {Information and Software Technology},
	author = {Hatton, Les},
	urldate = {2022-04-30},
	date = {2004-06-01},
	langid = {english},
	keywords = {Embedded control systems, Rule categories, Rule signal to noise, Safer language subsets},
	file = {ScienceDirect Snapshot:C\:\\Users\\lmjordao\\Zotero\\storage\\PXUXSANQ\\S0950584903002076.html:text/html},
}

% ------------------------- Intro to sw testing -------------------------
@article{intro_sw_testing,
	title = {Introduction to Software Testing Chapter 3.1, 3.2 Logic Coverage},
	pages = {30},
	journaltitle = {Introduction to Software Testing},
	author = {Ammann, Paul and Offutt, Jeff},
	langid = {english},
	file = {Ammann and Offutt - Introduction to Software Testing Chapter 3.1, 3.2 .pdf:C\:\\Users\\lmjordao\\Zotero\\storage\\IQYB8BFW\\Ammann and Offutt - Introduction to Software Testing Chapter 3.1, 3.2 .pdf:application/pdf},
}

% ------------------------- TCMS req guidelines -------------------------
@misc{tcms_req_guidelines,
	title = {3EGM015XXXXX\_\_en\_XXXXXX {TCMS} {GIVEN} {WHEN} {THEN} Instructions for developers and testers.docx},
	shorttitle = {{TCMS} requirements engineers to write {GIVEN}-{WHEN}-{THEN} software requirements},
	abstract = {{TCMS} requirements engineers to write {GIVEN}-{WHEN}-{THEN} software requirements},
	author = {Provenzano, Luciana},
	date = {2021-02-03},
}

@software{armin-montigny_evaluation_2022,
	title = {Evaluation of Boolean Expressions and {MCDC} test cases},
	rights = {{BSD}-3-Clause},
	url = {https://github.com/Armin-Montigny/MCDC},
	abstract = {Create minimum {MCDC} test sets for a boolean expression},
	author = {Armin-Montigny},
	urldate = {2022-05-08},
	date = {2022-04-17},
	note = {original-date: 2019-04-27T09:08:04Z},
	keywords = {mcdc, quine-mccluskey},
}

% ------------------------- Stop words -------------------------
@article{alajmi2012toward,
  title={Toward an ARABIC stop-words list generation},
  author={Alajmi, A and Saad, E Mostafa and Darwish, RR},
  journal={International Journal of Computer Applications},
  volume={46},
  number={8},
  pages={8--13},
  year={2012},
  publisher={Citeseer}
}